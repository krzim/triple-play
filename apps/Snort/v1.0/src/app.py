
import idstools.rule
import os
import re

import socket
import asyncio
import time
import logging

from app_sdk.app_base import AppBase
logger = logging.getLogger("apps")

class Snort(AppBase):
    __version__ = "v1.0"
    def __init__(self, redis=None, logger=None):
        super().__init__(redis, logger)


    def read_rules(self, path='/etc/snort/rules'):
        """
            Reads Snort rules from a directory. Takes in path to a directory with Snort rule files. 
            Defaults to /etc/snort/rules as that's the default for an installation on Ubuntu.
        """

        rules = []
        for root, _, files in os.walk(path):
            for rulefile in files:
                filerules = idstools.rule.parse_file(os.path.join(root, rulefile), None)
                for rule in filerules:
                    rules.append(rule)
        return rules


    def find_ip_in_alert_log(self, ip, path='/var/log/snort/alert'):
        """
            Searches an ASCII Snort Alert log for an ip address.
            Returns True if found, and False if not.
            Arguments:
                ip: IP Address to be found as a string.
                path: Path to alert log. Defaults to default alert log location on Ubuntu.
        """
        if os.path.exists(path):
            with open(path, "r") as alertlog:
                for line in alertlog:
                    if ip in line:
                        return True, "Success"
            return False, "NotFound"
        else:
            return False, "FileError"


    def write_alert_rule_based_on_ip(self, ip, file_name=None):
        """
            Writes a Snort rule to alert based on traffic incoming from an ip address.
            Arguments:
                ip: String with an ip address.
                filename: String with a path to a Snort rule file. Passed directly to writerule.
        """
        return_object = None
        if file_name is not None:
            return_object = write_rule(srcip=ip, options='msg: "Autogenerated rule to alert on '+ip+'."; '+ 'sid:'+ sid_generator() + ';', filename=file_name)
            return return_object.result, return_object.status
        else:
            return_object = write_rule(srcip=ip, options='msg: "Autogenerated rule to alert on '+ip+'."; '+ 'sid:'+ sid_generator() + ';')
            return return_object.result, return_object.status


    def write_rule(self, action='alert',
                    protocol='tcp',
                    srcip='$EXTERNAL_NET',
                    srcport='any',
                    direction='->',
                    dstip='$HOME_NET',
                    dstport='any',
                    options=None,
                    filename='/etc/snort/rules/walkoff.rules'
                    ):
        """
            Writes a Snort rule.
            Arguments:
            All arguments are strings.
            action: What the rule does, like alert, log, drop, etc. Defaults to alert
            protocol: Traffic protocol, like tcp, udp, ip, or icmp. Defaults to tcp
            srcip: IP Address or identifier for the address of the source of traffic. Defaults to an identifier for an External Network.
            srcport: Port of source traffic. Defaults to any port.
            direction: either ->,  or <>. <> is for checking bidirectional traffic. Defaults to ->
            dstip: IP Address or identifier for the address of the destination of traffic. Defaults to an identifier for the Home Network.
            dstport: Port of the destination traffic. Defaults to any.
            options: Optional string containing snort options, like msg, content, sid, etc.
            filename: Path to Snort rule file where the rule will be written. Defaults to a file called walkoff.rules in the default rules folder on Ubuntu.
        """
        header = ' '.join([action, protocol, srcip, srcport, direction, dstip, dstport])
        if options is not None:
            rule = header + ' (' + options + ')'
        else:
            rule = header

        try:
            with open(filename, 'a') as rulesfile:
                rulesfile.write(rule+"\n")
        except IOError:
            return False, "Failure"

        return True, "Success"


    def sid_generator(self, path=None):
        """
            Generates a Snort (signature) id for a rule by finding the greatest sid in the rules directory and adding 1 to that number for a new sid.
            Takes in an optional path argument that's passed to the readrules function.
        """
        maxsid = 0
        if path is not None:
            rules = read_rules(path)
        else:
            rules = read_rules()
        for rule in rules:
            if rule.sid is not None:
                if int(maxsid) < int(rule.sid):
                    maxsid = int(rule.sid)
        if maxsid < 1000000:
            maxsid = maxsid + 1000000
        else:
            maxsid = maxsid + 1
        return str(maxsid)


    def write_alert_multi_ip(self, ips, filename=None, alert_log_path='/var/log/snort/alert'):
        '''
            Loops through and calls write_alert_rule_based_on_ip for each IPv4 addr
            if Snort has not already alerted on that IP.
            Arguments:
                ips: String of IPv4's comma delimited.
                filename: String with a path to a Snort rule file. Passed directly to writerule.
                alert_log_path: Path to the alert log snort writes to
        '''

        # Matches '<IPv4 Address>,' repeated unlimited times
        pattern = '^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]),)+$'

        if re.match(pattern, ips) is None:
            return False, 'FailureStringIPs'
        else:
            comma_index = 0
            for i in range(0, len(ips)):
                if (ips[i] == ','):
                    ip = ips[comma_index:i]
                    found = find_ip_in_alert_log(ip, alert_log_path).result

                    if found:
                        comma_index = i + 1  # Need to get past the comma
                        continue

                    if not write_alert_rule_based_on_ip(ips[comma_index:i], filename).result:
                        return False, 'FailureWriteRule'

                    comma_index = i + 1  # Need to get past the comma

        return True, 'Success'

    def deletealertrulebasedonip(self, ip, file_name=None):
        """
            Deletes a Snort rule to alert based on traffic incoming from an ip address.
            Arguments:
                ip: String with an ip address.
                filename: String with a path to a Snort rule file. Passed directly to writerule.
        """
        found = False
        ipGroup = ip.split(" ")
        if file_name is not None:
            with open(file_name, 'r+') as f:
                #read in entire rule file and split by newline, get rid of empty item at end
                data = f.read().split("\n")[:-1]
                #overwrite file from beginning
                f.seek(0)
                for line in data:
                    for myIp in ipGroup:
                        if myIp in line:
                            found = True
                    #write down anything that doesn't match ips specified
                    if found == False:
                        f.write(line+'\n')
                        f.truncate()
                    else:
                        found = False
            return 'Success'
        else:
            return 'No File Found'

